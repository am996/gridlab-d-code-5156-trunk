// This file generated by staff_codegen
// For more information please visit: http://code.google.com/p/staff/
// Service Implementation

#include "my_microturbineImpl.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <iostream>
#include "complex.h"

///////////////////VARIABLE DEFINTIONS//////////////////////////////////

#define TS_NEVER ((int)(((unsigned int)-1)>>1))

///////////////////////////////////////////////////////

int gen_mode_v; //v=1,pg=2,pf=4 sd=5
int gen_status_v; //off=1, on=2
int power_type_v; //dc=1,ac=2
 double Rinternal;
	double Rload;
	complex V_Max;
	complex I_Max;

	double frequency;
	double Max_Frequency;
	double Min_Frequency;
	double Fuel_Used;
	double Heat_Out;
	double KV; //voltage constant
	double Power_Angle;

	double Max_P;//< maximum real power capacity in kW
        double Min_P;//< minimus real power capacity in kW

	double Max_Q;//< maximum reactive power capacity in kVar
        double Min_Q;//< minimus reactive power capacity in kVar
	double Rated_kVA; //< nominal capacity in kVA
	//double Rated_kV; //< nominal line-line voltage in kV

	double efficiency;

	complex E_A_Internal;
	complex E_B_Internal;
	complex E_C_Internal;

	complex phaseA_V_Out;//voltage
	complex phaseB_V_Out;
	complex phaseC_V_Out;

	//complex V_Out;

	complex phaseA_I_Out;      // current
	complex phaseB_I_Out;
	complex phaseC_I_Out;

	//complex I_Out;

	complex power_A_Out;//power
	complex power_B_Out;
	complex power_C_Out;

	complex VA_Out;

	double pf_Out;

	complex *pCircuit_V_A;//< pointer to the three voltages on three lines
	complex *pCircuit_V_B;
	complex *pCircuit_V_C;

	complex *pLine_I_A;			//< pointer to the three current on three lines
	complex *pLine_I_B;
	complex *pLine_I_C;
        double price;

	double determine_power_angle (complex power_out);
	complex determine_source_voltage(complex voltage_out, double r_internal, double r_load);
	double determine_frequency(complex power_out);
	double calculate_loss(double frequency_out);
	double determine_heat(complex power_out, double heat_loss);


///////////////////////SUNARTHSEIS POU DEN THA EINAI METHODOI TOU WEB SERVICE ALLA THA UPARXEI STHN YLOPOIHSH TOU////////////
double determine_power_angle (complex power_out){ //could also pass in pf_Out as a parameter if needed
	Power_Angle = acos((double) (power_out.Re() / power_out.Mag()));
	return Power_Angle;

}

complex determine_source_voltage(complex voltage_out, double r_internal, double r_load){
	//placeholder, probably need to replace with iterative function
	complex Vs = complex(((r_internal + r_load)/(r_load)) * voltage_out.Re(), ((r_internal + r_load)/(r_load)) * voltage_out.Im());
	return Vs;

}

double determine_frequency(complex power_out){
	//double Kx = 3 * Rinternal / 3.14159;
	//used linear approximation which does better job than textbook equation...
	//assumes power in W
	double f = power_out.Mag() * 1.5 + 55000;\
	f = f/60;
	return f;
}

double calculate_loss(double frequency_out){
	//placeholder
	return 0;
}

double determine_heat(complex power_out, double heat_loss){
	//placeholder;
	Heat_Out = power_out.Mag() * heat_loss;
	return Heat_Out;
}


my_microturbineImpl::my_microturbineImpl()
{
}

my_microturbineImpl::~my_microturbineImpl()
{
}

void my_microturbineImpl::OnCreate()
{
  // this function is called when service instance is created and registered
}

void my_microturbineImpl::OnDestroy()
{
  // this function is called immediately before service instance destruction
}

double my_microturbineImpl::microturbine_init()
{
	//generator_mode_choice = CONSTANT_PQ;
	gen_status_v = 2;

	Rinternal = 0.05;
	Rload = 1;
	V_Max = complex(10000);
	I_Max = complex(1000);

	frequency = 0;
	Max_Frequency = 2000;
	Min_Frequency = 0;
	Fuel_Used = 0;
	Heat_Out = 0;
	KV = 1; //voltage constant
	Power_Angle = 1;

	Max_P = 100;//< maximum real power capacity in kW
    Min_P = 0;//< minimus real power capacity in kW

	Max_Q = 100;//< maximum reactive power capacity in kVar
    Min_Q = 0;//< minimus reactive power capacity in kVar
	Rated_kVA = 150; //< nominal capacity in kVA
	//double Rated_kV; //< nominal line-line voltage in kV

	efficiency = 0;
	pf_Out = 1;

price = 0;//a numbrt;

	return price; /* return 1 on success, 0 on failure */

}

int my_microturbineImpl::microturbine_presync(int t0, int t1)
{
  int t2 = TS_NEVER;
	Heat_Out = Fuel_Used = frequency = 0.0;

	return t2; /* return t2>t1 on success, t2=t1 for retry, t2<t1 on failure */

}

double my_microturbineImpl::microturbine_sync(double CircuitA_V_Out_re, double CircuitA_V_Out_im, double CircuitB_V_Out_re, double CircuitB_V_Out_im, double CircuitC_V_Out_re, double CircuitC_V_Out_im, double LineA_V_Out_re, double LineA_V_Out_im, double LineB_V_Out_re, double LineB_V_Out_im, double LineC_V_Out_re, double LineC_V_Out_im)
{
  //gather V_Out for each phase
	//gather I_Out for each phase
	//gather VA_Out for each phase
	//gather Q_Out
	//gather S_Out
	//gather Pf_Out

	phaseA_V_Out.Re() = CircuitA_V_Out_re;
	phaseB_V_Out.Re() = CircuitB_V_Out_re;
	phaseC_V_Out.Re()= CircuitC_V_Out_re;

	phaseA_V_Out.Im() = CircuitA_V_Out_im;
	phaseB_V_Out.Im() = CircuitB_V_Out_im;
	phaseC_V_Out.Im()= CircuitC_V_Out_im;

	phaseA_I_Out.Re() = LineA_V_Out_re;
	phaseB_I_Out.Re() = LineB_V_Out_re;
	phaseC_I_Out.Re()= LineC_V_Out_re;

       phaseA_I_Out.Im() = LineA_V_Out_im;
       	phaseB_I_Out.Im() = LineB_V_Out_im;
       	phaseC_I_Out.Im()= LineC_V_Out_im;



	power_A_Out = (~phaseA_I_Out) * phaseA_V_Out;
	power_B_Out = (~phaseB_I_Out) * phaseB_V_Out;
	power_C_Out = (~phaseC_I_Out) * phaseC_V_Out;
printf("%f %f",phaseA_I_Out.Re(),phaseA_V_Out.Im());


	VA_Out = power_A_Out + power_B_Out + power_C_Out;

	E_A_Internal = determine_source_voltage(phaseA_V_Out, Rinternal, Rload);
	E_B_Internal = determine_source_voltage(phaseB_V_Out, Rinternal, Rload);
	E_C_Internal = determine_source_voltage(phaseC_V_Out, Rinternal, Rload);





	frequency = determine_frequency(VA_Out);



	double loss = calculate_loss(frequency);
	efficiency = 1 - loss;
	Heat_Out = determine_heat(VA_Out, loss);
	Fuel_Used = Heat_Out + VA_Out.Mag();



return VA_Out.Re();

}



