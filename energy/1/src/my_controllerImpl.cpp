// This file generated by staff_codegen
// For more information please visit: http://code.google.com/p/staff/
// Service Implementation

#include "my_controllerImpl.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <iostream>
#include "complex.h"
///definition of variables/////
#define TS_NEVER ((int)(((unsigned int)-1)>>1))
	double kT_L, kT_H;
	char target[33];
	char setpoint[33];
	char demand[33];
	char total[33];
	char load[33];
	char state[33];

	double last_p;
	double last_q;
	int value;
	double set_temp;
	int may_run;


	double clear_price;
	double ramp_low = -2;
	double ramp_high = -2;
	double range_low = 0;
	double range_high = 10;
	double dPeriod;
	int period;
	double slider_setting;
	double slider_setting_heat;
	double slider_setting_cool;

	double heat_range_high;
	double heat_range_low;
	double heat_ramp_high;
	double heat_ramp_low;
	double cool_range_high;
	double cool_range_low;
	double cool_ramp_high;
	double cool_ramp_low;



	double setpoint0;
	double heating_setpoint0;
	double cooling_setpoint0;
	double sliding_time_delay;
	int bid_delay;

	bool use_predictive_bidding;
	double last_setpoint;
	double last_heating_setpoint;
	double last_cooling_setpoint;



	double pMonitor;
	double pSetpoint;
	double pDemand;
	double pTotal;
	double pLoad;
	//double *pAvg;
///	double *pStd;
	int pState;
	int last_pState;

	int dir, direction;
	double min, max;
	double T_lim, k_T;
	double heat_min, heat_max;
	double cool_min, cool_max;
	double *pDeadband;
	double *pHeatingSetpoint;
	double *pCoolingSetpoint;
	double *pHeatingDemand;
	double *pCoolingDemand;
	double *pHeatingTotal;
	double *pCoolingTotal;
	double *pHeatingLoad;
	double *pCoolingLoad;
	int pHeatingState;
	int pCoolingState;
	double *pAuxState;
	double *pHeatState;
	double *pCoolState;

	int dtime_delay;

	bool use_market_period;

 enum therm_mode{
		TM_INVALID=0,
		TM_OFF=1,
		TM_HEAT=2,
		TM_COOL=3,
	} ;
	therm_mode thermostat_mode, last_mode, previous_mode;

 enum ovride{
		OU_OFF=0,
		OU_ON=1
	} ;
	ovride use_override;


my_controllerImpl::my_controllerImpl()
{
}

my_controllerImpl::~my_controllerImpl()
{
}

void my_controllerImpl::OnCreate()
{
  // this function is called when service instance is created and registered
}

void my_controllerImpl::OnDestroy()
{
  // this function is called immediately before service instance destruction
}

int my_controllerImpl::COinit(double market_init_price, int pstate, int market_period, int control_mode, double psetpoint, double base_setpoint, double heating_base_setpoint, double cooling_base_setpoint)
{
          slider_setting_heat = -0.001;
  	slider_setting_cool = -0.001;
  	slider_setting = -0.001;
  	sliding_time_delay = -1;

  	heat_range_low = -5;
  	heat_range_high = 3;
  	cool_range_low = -3;
  	cool_range_high = 5;
  	use_override = OU_OFF;
  	period = 0;
  	use_predictive_bidding = false;

  	period = market_period;


  	if(bid_delay < 0){
  		bid_delay = -bid_delay;
  		}



  	if(dir == 0){
  		double high = ramp_high * range_high;
  		double low = ramp_low * range_low;
  		if(high > low){
  			dir = 1;
  		} else if(high < low){
  			dir = -1;
  		} else if((high == low) && (fabs(ramp_high) > 0.001 || fabs(ramp_low) > 0.001)){
  			dir = 0;
  			if(ramp_high > 0){
  				direction = 1;
  			} else {
  				direction = -1;
  			}
  			//gl_warning("%s: controller has no price ramp", namestr);
  			/* occurs given no price variation, or no control width (use a normal thermostat?) */
  		}
  		if(ramp_low * ramp_high < 0){
  		//	gl_warning("%s: controller price curve is not injective and may behave strangely");
  			/* TROUBLESHOOT
  				The price curve 'changes directions' at the setpoint, which may create odd
  				conditions in a number of circumstances.
  			 */
  		}
  	}
  	if(base_setpoint==0)
  		base_setpoint = -1; // key to check first thing

  	if(heating_base_setpoint==0)
  		heating_base_setpoint = -1;

  	if(cooling_base_setpoint==0)
  		cooling_base_setpoint = -1;

  	if(sliding_time_delay < 0 )
  		dtime_delay = 21600; // default sliding_time_delay of 6 hours
  	else
  		dtime_delay = (int)sliding_time_delay;

  	if(state[0] != 0){
  		// grab state pointer
  		pState = pstate;
  		last_pState = 0;

  	}




  	if(control_mode == 0){
  		if(slider_setting < -0.001){
  			//gl_warning("slider_setting is negative, reseting to 0.0");
  			slider_setting = 0.0;
  		}
  		if(slider_setting > 1.0){
  			//gl_warning("slider_setting is greater than 1.0, reseting to 1.0");
  			slider_setting = 1.0;
  		}
  	}

  	last_p = market_init_price;
  	return last_p;

}

int my_controllerImpl::COpresync(double base_setpoint, double psetpoint, int control_mode)
{
 pSetpoint=psetpoint;
 	if(slider_setting < -0.001)
 		slider_setting = 0.0;
 	if(slider_setting_heat < -0.001)
 		slider_setting_heat = 0.0;
 	if(slider_setting_cool < -0.001)
 		slider_setting_cool = 0.0;
 	if(slider_setting > 1.0)
 		slider_setting = 1.0;
 	if(slider_setting_heat > 1.0)
 		slider_setting_heat = 1.0;
 	if(slider_setting_cool > 1.0)
 		slider_setting_cool = 1.0;

 	if(control_mode == 0 && base_setpoint == -1)
 		base_setpoint = psetpoint;


 	if(control_mode == 0){
 		if (slider_setting == -0.001){
 			min = base_setpoint + range_low;
 			max = base_setpoint + range_high;
 		} else if(slider_setting > 0){
 			min = base_setpoint + range_low * slider_setting;
 			max = base_setpoint + range_high * slider_setting;
 			if(range_low != 0)
 				ramp_low = -2 - (1 - slider_setting);
 			else
 				ramp_low = 0;
 			if(range_high != 0)
 				ramp_high = 2 + (1 - slider_setting);
 			else
 				ramp_high = 0;
 		} else {
 			min = base_setpoint;
 			max = base_setpoint;
 		}
 	}
 	if((thermostat_mode != TM_INVALID && thermostat_mode != TM_OFF) )
 		last_mode = thermostat_mode;
 	else if(thermostat_mode == TM_INVALID)
 		last_mode = TM_OFF;// this initializes last mode to off

 	if(thermostat_mode != TM_INVALID)
 		previous_mode = thermostat_mode;
 	else
 		previous_mode = TM_OFF;





	return TS_NEVER;

}

double my_controllerImpl::COsync(double load, double demand, int pstate, double total, double target, double pAvg, double pStd, double base_setpoint, int control_mode, double market_current_frameclearing_price)
{
 double bid = -1.0;
  	int no_bid = 0; // flag gets set when the current temperature drops in between the the heating setpoint and cooling setpoint curves
  	//double demand = 0.0;
  	double rampify = 0.0;
     double bid_offset=0.0001;
  	double deadband_shift = 0.0;
  	double shift_direction = 0.0;
  	double shift_setpoint = 0.0;
  	double prediction_ramp = 0.0;
  	double prediction_range = 0.0;
  	double midpoint = 0.0;
  	pMonitor =target;
  	pTotal=total;
  	pDemand=demand;
  	pLoad = load;
  	if(control_mode == 0){
  		// if market has updated, continue onwards

  			clear_price = market_current_frameclearing_price;


  			if(fabs(pStd) < bid_offset){
  				set_temp = base_setpoint;
  			} else if(clear_price < pAvg && range_low != 0){
  				set_temp = base_setpoint + (clear_price - pAvg) * fabs(range_low) / (ramp_low * pStd) + deadband_shift*shift_direction;
  			} else if(clear_price > pAvg && range_high != 0){
  				set_temp = base_setpoint + (clear_price - pAvg) * fabs(range_high) / (ramp_high * pStd) + deadband_shift*shift_direction;
  			} else {
  				set_temp = base_setpoint + deadband_shift*shift_direction;
  			}
  			//////////////////////////////////////////////////////////////////////////////////////////////////
  			/*if((use_override == OU_ON) && (pOverride != 0)){
  				if(clear_price <= last_p){
  					// if we're willing to pay as much as, or for more than the offered price, then run.
  					*pOverride = 1;
  				} else {
  					*pOverride = -1;
  				}
  			}*/
  			///////////////////////////////////////////////////////////////////////////////////////////////////
  			// clip
  			if(set_temp > max){
  				set_temp = max;
  			} else if(set_temp < min){
  				set_temp = min;
  			}

  			pSetpoint = set_temp;
  			//gl_verbose("controller::postsync(): temp %f given p %f vs avg %f",set_temp, market->next.price, market->avg24);

  		/*
  		if(dir > 0){
  			if(use_predictive_bidding == TRUE){
  				if(pState == 0 && *pMonitor > (max - deadband_shift)){
  					bid = 9999;
  				} else if(pState != 0 && *pMonitor < (min + deadband_shift)){
  					bid = 0.0;
  					no_bid = 1;
  				} else if(pState != 0 && *pMonitor > max){
  					bid = 9999;
  				} else if(pState == 0 && *pMonitor < min){
  					bid = 0.0;
  					no_bid = 1;
  				}
  			} else {
  				if(*pMonitor > max){
  					bid = 9999;
  				} else if (*pMonitor < min){
  					bid = 0.0;
  					no_bid = 1;
  				}
  			}
  		} else if(dir < 0){
  			if(use_predictive_bidding == TRUE){
  				if(pState == 0 && *pMonitor < (min + deadband_shift)){
  					bid = 9999;
  				} else if(pState != 0 && *pMonitor > (max - deadband_shift)){
  					bid = 0.0;
  					no_bid = 1;
  				} else if(pState != 0 && *pMonitor < min){
  					bid = 9999;
  				} else if(*pState == 0 && *pMonitor > max){
  					bid = 0.0;
  					no_bid = 1;
  				}
  			} else {
  				if(*pMonitor < min){
  					bid = 9999;
  				} else if (*pMonitor > max){
  					bid = 0.0;
  					no_bid = 1;
  				}
  			}
  		} else if(dir == 0){
  			if(use_predictive_bidding == TRUE){
  				if(direction == 0.0) {
  					//gl_error("the variable direction did not get set correctly.");
  				} else if((*pMonitor > max + deadband_shift || (pState != 0 && *pMonitor > min - deadband_shift)) && direction > 0){
  					bid = 999;
  				} else if((*pMonitor < min - deadband_shift || (pState != 0 && *pMonitor < max + deadband_shift)) && direction < 0){
  					bid = 9999;
  				} else {
  					bid = 0.0;
  					no_bid = 1;
  				}
  			} else {
  				if(*pMonitor < min){
  					bid = 9999;
  				} else if(*pMonitor > max){
  					bid = 0.0;
  					no_bid = 1;
  				} else {
  					bid = pAvg;
  				}
  			}
  		}
  */
  		// calculate bid price
  		if(pMonitor > base_setpoint){
  			k_T = ramp_high;
  			T_lim = range_high;
  		} else if(pMonitor < base_setpoint) {
  			k_T = ramp_low;
  			T_lim = range_low;
  		} else {
  			k_T = 0.0;
  			T_lim = 0.0;
  		}


  		if(bid < 0.0 && pMonitor != base_setpoint) {
  			bid = pAvg + ( (fabs(pStd) < bid_offset) ? 0.0 : (pMonitor - base_setpoint) * (k_T * pStd) / fabs(T_lim) );
  		} else if(pMonitor == setpoint0) {
  			bid = pAvg;
  		}


  		// bid the response part of the load
  		double residual = pTotal;

  		if(pDemand > 0 && no_bid != 1){
  			//printf("if(*pDemand > 0 && no_bid != 1)\n");
  			last_p = bid;
  			last_q = pDemand;


  			residual -= pLoad;

  		} else {

  			last_p = 0;
  			last_q = 0;


  	}
 bid = pAvg + ( (fabs(pStd) < bid_offset) ? 0.0 : (pMonitor - base_setpoint) * (k_T * pStd) / fabs(T_lim) );

 printf("%f      ",pAvg );
	return last_p;

}
}

double my_controllerImpl::COpostsync(int control_mode, double base_setpoint)
{
   if(last_setpoint != base_setpoint && control_mode == 0)
		last_setpoint = base_setpoint;
	return last_setpoint;
}



