// This file generated by staff_codegen
// For more information please visit: http://code.google.com/p/staff/
// Service Implementation

#include "my_controllerImpl.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <iostream>
#include "complex.h"

#define TS_NEVER ((int)(((unsigned int)-1)>>1))
	double kT_L, kT_H;
	char target[33];
	char setpoint[33];
	char demand[33];
	char total[33];
	char load[33];
	char state[33];

	double last_p;
	double last_q;
	int value;
	double set_temp;
	int may_run;


	double clear_price;
	double ramp_low = -2;
	double ramp_high = -2;
	double range_low = 0;
	double range_high = 10;
	double dPeriod;
	int period;
	double slider_setting;
	double slider_setting_heat;
	double slider_setting_cool;

	double heat_range_high;
	double heat_range_low;
	double heat_ramp_high;
	double heat_ramp_low;
	double cool_range_high;
	double cool_range_low;
	double cool_ramp_high;
	double cool_ramp_low;



	double setpoint0;
	double heating_setpoint0;
	double cooling_setpoint0;
	double sliding_time_delay;
	int bid_delay;

	bool use_predictive_bidding;
	double last_setpoint;
	double last_heating_setpoint;
	double last_cooling_setpoint;



	double pMonitor;
	double pSetpoint;
	double pDemand;
	double pTotal;
	double pLoad;
	//double *pAvg;
///	double *pStd;
	int pState;
	int last_pState;

	int dir, direction;
	double min, max;
	double T_lim, k_T;
	double heat_min, heat_max;
	double cool_min, cool_max;
	double *pDeadband;
	double *pHeatingSetpoint;
	double *pCoolingSetpoint;
	double *pHeatingDemand;
	double *pCoolingDemand;
	double *pHeatingTotal;
	double *pCoolingTotal;
	double *pHeatingLoad;
	double *pCoolingLoad;
	int pHeatingState;
	int pCoolingState;
	double *pAuxState;
	double *pHeatState;
	double *pCoolState;

	int dtime_delay;

	bool use_market_period;

 enum therm_mode{
		TM_INVALID=0,
		TM_OFF=1,
		TM_HEAT=2,
		TM_COOL=3,
	} ;
	therm_mode thermostat_mode, last_mode, previous_mode;

 enum ovride{
		OU_OFF=0,
		OU_ON=1
	} ;
	ovride use_override;

my_controllerImpl::my_controllerImpl()
{
}

my_controllerImpl::~my_controllerImpl()
{
}

void my_controllerImpl::OnCreate()
{
  // this function is called when service instance is created and registered
}

void my_controllerImpl::OnDestroy()
{
  // this function is called immediately before service instance destruction
}

int my_controllerImpl::COinit(double market_init_price, int pstate, int market_period, int control_mode, double psetpoint, double base_setpoint, double heating_base_setpoint, double cooling_base_setpoint)
{
   if(last_setpoint != base_setpoint && control_mode == 0)
		last_setpoint = base_setpoint;

	return last_setpoint;
}

int my_controllerImpl::COpresync(double base_setpoint, double psetpoint, int control_mode)
{
 double bid = -1.0;
  	int no_bid = 0; // flag gets set when the current temperature drops in between the the heating setpoint and cooling setpoint curves
  	//double demand = 0.0;
  	double rampify = 0.0;
     double bid_offset=0.0001;
  	double deadband_shift = 0.0;
  	double shift_direction = 0.0;
  	double shift_setpoint = 0.0;
  	double prediction_ramp = 0.0;
  	double prediction_range = 0.0;
  	double midpoint = 0.0;
  	pMonitor =target;
  	pTotal=total;
  	pDemand=demand;
  	pLoad = load;
  	if(control_mode == 0){
  		// if market has updated, continue onwards

  			clear_price = market_current_frameclearing_price;


  			if(fabs(pStd) < bid_offset){
  				set_temp = base_setpoint;
  			} else if(clear_price < pAvg && range_low != 0){
  				set_temp = base_setpoint + (clear_price - pAvg) * fabs(range_low) / (ramp_low * pStd) + deadband_shift*shift_direction;
  			} else if(clear_price > pAvg && range_high != 0){
  				set_temp = base_setpoint + (clear_price - pAvg) * fabs(range_high) / (ramp_high * pStd) + deadband_shift*shift_direction;
  			} else {
  				set_temp = base_setpoint + deadband_shift*shift_direction;
  			}
  			//////////////////////////////////////////////////////////////////////////////////////////////////
  			/*if((use_override == OU_ON) && (pOverride != 0)){
  				if(clear_price <= last_p){
  					// if we're willing to pay as much as, or for more than the offered price, then run.
  					*pOverride = 1;
  				} else {
  					*pOverride = -1;
  				}
  			}*/
  			///////////////////////////////////////////////////////////////////////////////////////////////////
  			// clip
  			if(set_temp > max){
  				set_temp = max;
  			} else if(set_temp < min){
  				set_temp = min;
  			}

  			pSetpoint = set_temp;
  			//gl_verbose("controller::postsync(): temp %f given p %f vs avg %f",set_temp, market->next.price, market->avg24);

  		/*
  		if(dir > 0){
  			if(use_predictive_bidding == TRUE){
  				if(pState == 0 && *pMonitor > (max - deadband_shift)){
  					bid = 9999;
  				} else if(pState != 0 && *pMonitor < (min + deadband_shift)){
  					bid = 0.0;
  					no_bid = 1;
  				} else if(pState != 0 && *pMonitor > max){
  					bid = 9999;
  				} else if(pState == 0 && *pMonitor < min){
  					bid = 0.0;
  					no_bid = 1;
  				}
  			} else {
  				if(*pMonitor > max){
  					bid = 9999;
  				} else if (*pMonitor < min){
  					bid = 0.0;
  					no_bid = 1;
  				}
  			}
  		} else if(dir < 0){
  			if(use_predictive_bidding == TRUE){
  				if(pState == 0 && *pMonitor < (min + deadband_shift)){
  					bid = 9999;
  				} else if(pState != 0 && *pMonitor > (max - deadband_shift)){
  					bid = 0.0;
  					no_bid = 1;
  				} else if(pState != 0 && *pMonitor < min){
  					bid = 9999;
  				} else if(*pState == 0 && *pMonitor > max){
  					bid = 0.0;
  					no_bid = 1;
  				}
  			} else {
  				if(*pMonitor < min){
  					bid = 9999;
  				} else if (*pMonitor > max){
  					bid = 0.0;
  					no_bid = 1;
  				}
  			}
  		} else if(dir == 0){
  			if(use_predictive_bidding == TRUE){
  				if(direction == 0.0) {
  					//gl_error("the variable direction did not get set correctly.");
  				} else if((*pMonitor > max + deadband_shift || (pState != 0 && *pMonitor > min - deadband_shift)) && direction > 0){
  					bid = 999;
  				} else if((*pMonitor < min - deadband_shift || (pState != 0 && *pMonitor < max + deadband_shift)) && direction < 0){
  					bid = 9999;
  				} else {
  					bid = 0.0;
  					no_bid = 1;
  				}
  			} else {
  				if(*pMonitor < min){
  					bid = 9999;
  				} else if(*pMonitor > max){
  					bid = 0.0;
  					no_bid = 1;
  				} else {
  					bid = pAvg;
  				}
  			}
  		}
  */
  		// calculate bid price
  		if(pMonitor > base_setpoint){
  			k_T = ramp_high;
  			T_lim = range_high;
  		} else if(pMonitor < base_setpoint) {
  			k_T = ramp_low;
  			T_lim = range_low;
  		} else {
  			k_T = 0.0;
  			T_lim = 0.0;
  		}


  		if(bid < 0.0 && pMonitor != base_setpoint) {
  			bid = pAvg + ( (fabs(pStd) < bid_offset) ? 0.0 : (pMonitor - base_setpoint) * (k_T * pStd) / fabs(T_lim) );
  		} else if(pMonitor == setpoint0) {
  			bid = pAvg;
  		}


  		// bid the response part of the load
  		double residual = pTotal;

  		if(pDemand > 0 && no_bid != 1){
  			//printf("if(*pDemand > 0 && no_bid != 1)\n");
  			last_p = bid;
  			last_q = pDemand;


  			residual -= pLoad;

  		} else {

  			last_p = 0;
  			last_q = 0;


  	}
 bid = pAvg + ( (fabs(pStd) < bid_offset) ? 0.0 : (pMonitor - base_setpoint) * (k_T * pStd) / fabs(T_lim) );

 printf("%f      ",pAvg );
	return last_p;

}

double my_controllerImpl::COsync(double load, double demand, int pstate, double total, double target, double pAvg, double pStd, double base_setpoint, int control_mode, double market_current_frameclearing_price)
{
  double tResult;
  // TODO: place your code here

  return tResult;  // result
}

double my_controllerImpl::COpostsync(int control_mode, double base_setpoint)
{
  double tResult;
  // TODO: place your code here

  return tResult;  // result
}



