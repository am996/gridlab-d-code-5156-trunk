// This file generated by staff_codegen
// For more information please visit: http://code.google.com/p/staff/
// Service Implementation

#include "my_solarImpl.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <iostream>
#include "complex.h"

///////////////////VARIABLE DEFINTIONS//////////////////////////////////


#define TS_NEVER ((int)(((unsigned int)-1)>>1))
int gen_mode_v;  //operating mode of the generator 
	//note solar panel will always operate under the SUPPLY_DRIVEN generator mode
	int  gen_status_v;
	int power_type_v; //ac=1, dc=2
	int panel_type_v;
        int installation_type_v;
	int solar_model_tilt;
	int  solar_power_model;

	double NOCT;
	double Tcell;
	double Tmodule;
	double Tambient;
	double Insolation;
	double Rinternal;
	double Rated_Insolation;
	complex V_Max;
	complex Voc;
	complex Voc_Max;
	double area;
	double Tamb;
	double wind_speed;
	double Pmax_temp_coeff;
        double Voc_temp_coeff;
        double w1;
        double w2;
	double w3;
	double constant;
	complex P_Out;
	complex V_Out;
	complex I_Out;
	complex VA_Out;

	//Variables for temperature correction - obtained from Sandia database for module types
	double module_acoeff;			//Temperature correction coefficient a
	double module_bcoeff;			//Temperature correction coefficient b
	double module_dTcoeff;			//Temperature difference coefficient associated with insolation heating
	double module_Tcoeff;			//Maximum power temperature coefficient

	double shading_factor;			//Shading factor
	double tilt_angle;				//Installation tilt angle
	double orientation_azimuth;		//published Orientation of the array
	bool fix_angle_lat;				//Fix tilt angle to latitude (replicates NREL SAM function)
	double soiling_factor;			//Soiling factor to be applied - makes user specifiable
	double derating_factor;			//Inverter derating factor - makes user specifiable

	int  orientation_type;	//Describes orientation features of PV //default=0

	//FUNCTIONADDR calc_solar_radiation;	//Function pointer to climate's calculate solar radiation in degrees
		
	
	double efficiency;
	double *pTout;
	double prevTemp, currTemp;
	int prevTime;
	double *pRhout;
	double *pSolarD;		//Direct solar radiation
	double *pSolarH;		//Horizontal solar radiation
	double *pSolarG;		//Global horizontal
	double *pAlbedo;		//Ground reflectance
	double *pWindSpeed;

	double Max_P;//< maximum real power capacity in kW
        double Min_P;//< minimus real power capacity in kW
	//double Max_Q;//< maximum reactive power capacity in kVar
    //double Min_Q;//< minimus reactive power capacity in kVar
	double Rated_kVA; //< nominal capacity in kVA
	
	complex *pCircuit_V;		//< pointer to the three voltages on three lines
	complex *pLine_I;	
	double orientation_azimuth_corrected;
	
double price;

//////////////////////////////////////////////////////////////////////////////////
///////////////////////SUNARTHSEIS POU DEN THA EINAI METHODOI TOU WEB SERVICE ALLA THA UPARXEI STHN YLOPOIHSH TOU////////////

int solarinit_climate()
{
  		
		

			//default to mock data
			static double tout=59.0, rhout=0.75, solar=92.902, wsout=0.0, albdefault=0.2;
			pTout = &tout;
			pRhout = &rhout;
			pSolarD = &solar;	//Default all solar values to normal "optimal" 1000 W/m^2
			pSolarH = &solar;
			pSolarG = &solar;
			pAlbedo = &albdefault;
			pWindSpeed = &wsout;



	return 1;
}


my_solarImpl::my_solarImpl()
{
}

my_solarImpl::~my_solarImpl()
{
}

void my_solarImpl::OnCreate()
{
  // this function is called when service instance is created and registered
}

void my_solarImpl::OnDestroy()
{
  // this function is called immediately before service instance destruction
}

double my_solarImpl::solarcreate()
{
 //NOCT = 45; Tcell = 21; Tambient = 25;//degC ; Rated_Insolation = 1000;//rated insolation is 1000 W/m2 , taken from GE solar cell performance sheet
	// 1 sq m  = 10.764 sq ft.
	NOCT = 118.4; //degF
    Tcell = 21.0;  //degC
	Tambient = 25.0; //degC
	Tamb = 77;	//degF
	wind_speed = 0.0;
	Insolation = 0;
	Rinternal = 0.05;
	prevTemp = 15.0;	//Start at a reasonable ambient temp (degC) - default temp is 59 degF = 15 degC
	currTemp = 15.0;	//Start at a reasonable ambient temp (degC)
	prevTime = 0;
	Rated_Insolation = 92.902; //W/Sf for 1000 W/m2
    V_Max = complex (27.1,0);  // max. power voltage (Vmp) from GE solar cell performance charatcetristics
	Voc_Max = complex(34,0); //taken from GEPVp-200-M-Module performance characteristics
	Voc = complex (34,0);  //taken from GEPVp-200-M-Module performance characteristics
	P_Out = 0.0;

	area = 323; //sq f , 30m2
    
	//Defaults for flagging
	efficiency = 0;
	Pmax_temp_coeff = 0.0;
	Voc_temp_coeff  = 0.0;

	pSolarD = NULL;
	pSolarH = NULL;
	pSolarG = NULL;
	pAlbedo = NULL;
	pWindSpeed = NULL;
price=0.7;
	module_acoeff = -2.81;		//Coefficients from Sandia database - represents 
	module_bcoeff = -0.0455;	//glass/cell/polymer sheet insulated back, raised structure mounting
	module_dTcoeff = 0.0;		
	module_Tcoeff = -0.5;		//%/C - default from SAM - appears to be a monocrystalline or polycrystalline silicon

	shading_factor = 1;					//By default, no shading
	tilt_angle = 45;					//45-deg angle by default
	orientation_azimuth = 180.0;		//Equator facing, by default - for LIUJORDAN model
	orientation_azimuth_corrected = 0;	//By default, still zero
	fix_angle_lat = false;				//By default, tilt angle fix not enabled (because ideal insolation, by default)

	soiling_factor = 0.95;				//Soiling assumed to block 5% solar irradiance
	derating_factor = 0.95;				//Manufacturing variations expected to remove 5% of energy

	orientation_type = 0;	//Default = ideal tracking
	solar_model_tilt = 0;	//LIUJORDAN //"Classic" tilt model - from Duffie and Beckman (same as ETP inputs)
	solar_power_model = 0; //BASEEFFICIENT =0Use older power output calculation model - unsure where it came from

	//Null out the function pointers
	//calc_solar_radiation = NULL;

	return price; /* return 1 on success, 0 on failure */

}

int my_solarImpl::solarinit(int gen_mode_v, int gen_status_v, int panel_type_v)
{
 int climate_result;

	
	switch(panel_type_v)
	{
		case 1:
			if (efficiency==0.0)
				efficiency = 0.2;
       
			if (Pmax_temp_coeff==0.0)
				Pmax_temp_coeff = -0.00437/33.8 ;  // average values from ref 2 in per degF
			if (Voc_temp_coeff==0.0)
			   Voc_temp_coeff  = -0.00393/33.8;
		   break;
		case 2:
			if (efficiency==0.0)
				efficiency = 0.15;
			if (Pmax_temp_coeff==0.0)
				Pmax_temp_coeff = -0.00416/33.8; // average values from ref 2
			if (Voc_temp_coeff==0.0)
				Voc_temp_coeff  = -0.0039/33.8;
			break;
		case 3:
			if (efficiency==0.0)
				efficiency = 0.07;
			if (Pmax_temp_coeff==0.0)
			   Pmax_temp_coeff = 0.1745/33.8; // average values from ref 2
			if (Voc_temp_coeff==0.0)
			   Voc_temp_coeff  = -0.00407/33.8;
		   break;
		case 4:
			if (efficiency==0.0)
				efficiency = 0.3;
			break;
		case 5:
			if (efficiency==0.0)
				efficiency = 0.15;
			break;
		default:
			if (efficiency == 0)
				efficiency = 0.10;
			break;
	}

	static complex default_line_voltage[1], default_line_current[1];
	int i;

	
	Max_P = Rated_Insolation * efficiency * area; // We are calculating the module efficiency which should be less than cell efficiency. What about the sun hours??



	climate_result=solarinit_climate();

	//Check factors
	if ((soiling_factor<0) || (soiling_factor>1.0))
	{
		soiling_factor = 0.95;
		//gl_warning("Invalid soiling factor specified, defaulting to 95%");
		/*  TROUBLESHOOT
		A soiling factor less than zero or greater than 1.0 was specified.  This is not within the valid
		range, so a default of 0.95 was selected.
		*/
	}

	if ((derating_factor<0) || (derating_factor>1.0))
	{
		derating_factor = 0.95;
		//gl_warning("Invalid derating factor specified, defaulting to 95%");
		/*  TROUBLESHOOT
		A derating factor less than zero or greater than 1.0 was specified.  This is not within the valid
		range, so a default of 0.95 was selected.
		*/
	}

	return climate_result; /* return 1 on success, 0 on failure */

}

double my_solarImpl::solarsync(int t0, int t1)
{
double insolwmsq, corrwindspeed, Tback, Ftempcorr;
    solarinit_climate();
	//Check the shading factor
	if ((shading_factor <0) || (shading_factor > 1))
	{//return 0.0;
	}

	if (solar_model_tilt != 2)
	{
		//Update windspeed - since it's being read and has a variable
		wind_speed = *pWindSpeed;
		Tamb = *pTout;

		//Check our mode
		switch (orientation_type) {
			case 0:
				{
				Insolation = shading_factor*(*pSolarD) + *pSolarH + *pSolarG*(1 - cos(tilt_angle))*(*pAlbedo)/2.0;
					break;
				}
			case 1:
			case 2:
			case 3:
			case 4:
			default:
				{
				//return 0.0;
				//GL_THROW("Unknown or unsupported orientation detected");
					/*  TROUBLESHOOT
					While attempting to calculate solar output, an unknown, or currently unimplemented,
					orientation was detected.  Please try again.
					*/
				}
		}
	}
	//Default else - pull in from published values (player driven)

	//Tmodule = w1 *Tamb + w2 * Insolation + w3* wind_speed + constant;
	if (Insolation < 0.0){
		Insolation = 0.0;
	}

	if (solar_power_model==0)
	{
		Tambient = (Tamb-32.0)*5.0/9.0;  //Read Tamb into the variable - convert to degC for consistency (with below - where the algorithm is more complex and I'm too lazy to convert it to degF in MANY places)

		Tmodule = Tamb + (NOCT-68)/74.32 * Insolation;   //74.32 sf = 800 W/m2; 68 deg F = 20deg C
	     
		 VA_Out = Max_P * Insolation/Rated_Insolation *(1+(Pmax_temp_coeff)*( Tmodule-77))*derating_factor*soiling_factor; //derating due to manufacturing tolerance, derating sue to soiling both dimensionless
	}
	else if (solar_power_model==1)	//Flat plate efficiency
	{
		//Approach taken from NREL SAM documentation for flat plate efficiency model - unclear on its origins

		//Cycle temperature differences through if using flat efficiency model
		if (prevTime != t0)
		{
		//	prevTemp = currTemp;	//Current becomes previous

		//	currTemp = (Tamb-32.0)*5.0/9.0;  //Convert current temperature back to metric

		//	prevTime = t0;			//Record current timestep
		}

		//Get the "ambient" temperature of the array - by SAM algorithm, taken as
		//halfway between last intervals (linear interpolation)
		Tambient = prevTemp + (currTemp-prevTemp)/2.0;

		//Impose numerical error by converting things back into metric
		//First put insolation back into W/m^2 - factor in soiling at this point
		insolwmsq = Insolation*10.7639104*soiling_factor;	//Convert to W/m^2
		
		//Convert wind speed from mph to m/s
		corrwindspeed = wind_speed*0.44704;
		
		//Calculate the "back" temperature of the array
		Tback = (insolwmsq*exp(module_acoeff + module_bcoeff*corrwindspeed) + Tambient);

		//Now compute the cell temperature, based on the back temperature
		Tcell = Tback + insolwmsq/1000.0*module_dTcoeff;

		//TCell is assumed to be Tmodule from old calculations (used in voltage below) - convert back to Fahrenheit
		Tmodule=Tcell*9.0/5.0 + 32.0;

		//Calculate temperature correction value
		Ftempcorr = 1.0 + module_Tcoeff*(Tcell-25.0)/100.0;

		//Place into the DC value - factor in area, derating, and all of the related items
		P_Out = Insolation*soiling_factor*derating_factor*area*efficiency*Ftempcorr;
		
		//Populate VA, just because it seems to be used below
		VA_Out = P_Out;
	}
	else
	{
	//return 0.0;
		//GL_THROW("Unknown solar power output model selected!");
		/*  TROUBLESHOOT
		An unknown value was put in for the solar power output model.  Please
		choose a correct value.  If the value is correct and the error persists, please
		submit your code and a bug report via the trac website.
		*/
	}

	 Voc = Voc_Max * (1+(Voc_temp_coeff)*(Tmodule-77));
			    
	 V_Out = V_Max * (Voc/Voc_Max);

     I_Out = (VA_Out/V_Out);
     
complex powe2r=V_Out+I_Out;
	
	
	return powe2r.Re(); 

}



