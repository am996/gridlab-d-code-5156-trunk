// This file generated by staff_codegen
// For more information please visit: http://code.google.com/p/staff/
// Service Implementation

#include "my_wind_turbineImpl.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <iostream>
#include "complex.h"

///////////////////VARIABLE DEFINTIONS//////////////////////////////////

#define TS_NEVER ((int)(((unsigned int)-1)>>1))
        complex AMx[3][3];			//Impedance matrix for Synchronous Generator
	complex invAMx[3][3];		//Inverse of SG impedance matrix
	complex IndTPMat[2][2];		//Induction Generator two port matrix
	complex Vapu;				//Per unit voltage and current for Induction Generator at terminals
	complex Vbpu;
	complex Vcpu;
	complex Iapu;
	complex	Ibpu;
	complex	Icpu;
	double air_dens;
	double Ridealgas;
	double Molar;
	double std_air_dens;
	double std_air_temp;
	double std_air_press;
	complex *pCircuit_V;		//< pointer to the three voltages on three lines
	complex *pLine_I;			//< pointer to the three current on three lines
	bool last_NR_mode;		//Toggle to keep track of last NR mode - needed to differentiate between FBS and NR



	complex power_A;//power
	complex power_B;
	complex power_C;

	int Gen_status; //OFFLINE=1, ONLINE
	//INDUCTION=1, SYNCHRONOUS, USER_TYPE};
	int Gen_type;
	// {CONSTANTE=1, CONSTANTP, CONSTANTPQ};
	int Gen_mode;
	// {GENERIC_SYNCH_SMALL, GENERIC_SYNCH_MID,GENERIC_SYNCH_LARGE, GENERIC_IND_SMALL, GENERIC_IND_MID, GENERIC_IND_LARGE, USER_DEFINED, VESTAS_V82, GE_25MW, BERGEY_10kW};
	int Turbine_Model;
	//{GENERAL_LARGE, GENERAL_MID,GENERAL_SMALL,MANUF_TABLE, CALCULATED, USER_SPECIFY};
	int CP_Data;

	double blade_diam;
	double turbine_height;
	double roughness_l;
	double ref_height;
	double Cp;

	int time_advance;

	double avg_ws;				//Default value for wind speed
	double cut_in_ws;			//Values are used to find GENERIC Cp
	double cut_out_ws;			// |
	double Cp_max;				// |
	double ws_maxcp;			// |
	double Cp_rated;			// |
	double ws_rated;			// |

	double q;					//number of gearboxes

        double * pPress;			//Used to find air density
	double * pTemp;				// |
	double * pWS;				// |
	double * pair_density;		// |
	double Pconv;				//Power converted from mechanical to electrical before elec losses
	double GenElecEff;			//Generator electrical efficiency used for testing

	unsigned int *n;

	complex voltage_A;			//terminal voltage
	complex voltage_B;
	complex voltage_C;
	complex current_A;			//terminal current
	complex current_B;
	complex current_C;
	double store_last_current;  // Store the last solved current to see if the solution is converged

	double TotalRealPow;		//Real power supplied by generator - used for testing
	double TotalReacPow;		//Reactive power supplied - used for testing

	double Rated_VA;			// nominal capacity in VA
	double Rated_V;				// nominal line-line voltage in V
	double WSadj;				//Wind speed after all adjustments have been made (height, terrain, etc)
	double Wind_Speed;

	//Synchronous Generator
	complex EfA;				// induced voltage on phase A in V
	complex EfB;				// |
	complex EfC;				// |
	double Rs;					// internal transient resistance in p.u.
	double Xs;					// internal transient impedance in p.u.
    double Rg;					// grounding resistance in p.u.
	double Xg;					// grounding impedance in p.u.
	double Max_Ef;				// maximum induced voltage in p.u., e.g. 1.2
    double Min_Ef;				// minimum induced voltage in p.u., e.g. 0.8
	double Max_P;				// maximum real power capacity in kW
    double Min_P;				// minimum real power capacity in kW
	double Max_Q;				// maximum reactive power capacity in kVar
    double Min_Q;				// minimum reactive power capacity in kVar
	double pf;					// desired power factor - TO DO: implement later use with controller

	//Induction Generator
	complex Vrotor_A;			// induced "rotor" voltage in pu
	complex Vrotor_B;			// |
	complex Vrotor_C;			// |
	complex Irotor_A;			// "rotor" current generated in pu
	complex Irotor_B;			// |
	complex Irotor_C;			// |
	double Rst;					// stator internal impedance in p.u.
	double Xst;					// |
	double Rr;					// rotor internal impedance in p.u.
	double Xr;					// |
	double Rc;					// core/magnetization impedance in p.u.
	double Xm;					// |
	double Max_Vrotor;			// maximum induced voltage in p.u., e.g. 1.2
    double Min_Vrotor;			// minimum induced voltage in p.u., e.g. 0.8

	bool *NR_mode;			//Toggle for NR solving cycle.  If not NR, just goes to false
	bool default_NR_mode;

	    double pLine_I_A_Re;
	    double pLine_I_A_Im;
	    double pLine_I_B_Re;
	    double pLine_I_B_Im;
	    double pLine_I_C_Re;
	    double pLine_I_C_Im;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////SUNARTHSH POU DEN THA EINAI METHODOS TOU WEB SERVICE ALLA THA UPARXEI STHN YLOPOIHSH TOU////////////
int windturb_dginit_climate()
{




		//default to mock data
static double air_dens = std_air_dens;
static double avgWS = avg_ws;
static double Press = std_air_press;
static double Temp = std_air_temp;
		pWS = &avgWS;
		pPress = &Press;
		pTemp = &Temp;



	return 1;
}


my_wind_turbineImpl::my_wind_turbineImpl()
{
}

my_wind_turbineImpl::~my_wind_turbineImpl()
{
}

void my_wind_turbineImpl::OnCreate()
{
  // this function is called when service instance is created and registered
}

void my_wind_turbineImpl::OnDestroy()
{
  // this function is called immediately before service instance destruction
}

double my_wind_turbineImpl::windturb_dgcreate()
{
  // Defaults usually inside the create function

	roughness_l = .055;		//European wind atlas def for terrain roughness, values range from 0.0002 to 1.6
	ref_height = 10;		//height wind data was measured (Most meteorological data taken at 5-15 m)
	Max_Vrotor = 1.2;
	Min_Vrotor = 0.8;
	Max_Ef = 1.2;
	Min_Ef = 0.8;
	avg_ws = 8;				//wind speed in m/s

	time_advance = 3600;	//amount of time to advance for WS data import in secs.

	/* set the default values of all properties here */
	Ridealgas = 8.31447;
	Molar = 0.0289644;
	std_air_dens = 1.2754;	//dry air density at std pressure and temp in kg/m^3
	std_air_temp = 0;	//IUPAC std air temp in Celsius
	std_air_press = 100000;	//IUPAC std air pressure in Pascals
	Turbine_Model = 2;	//************** Default specified so it doesn't crash out*/
	Gen_mode = 1;					//************** Default specified so values actually come out*/
	Gen_status = 2;

	turbine_height = -9999;
	blade_diam = -9999;
	cut_in_ws = -9999;
	cut_out_ws = -9999;
	Cp_max = -9999;
	Cp_rated =-9999;
	ws_maxcp = -9999;
	ws_rated = -9999;
	CP_Data = 3;

	default_NR_mode = false;

	return 1; /* return 1 on success, 0 on failure */

}

int my_wind_turbineImpl::windturb_dginit(double pLine_I_A_Re, double pLine_I_A_Im, double pLine_I_B_Re, double pLine_I_B_Im, double pLine_I_C_Re, double pLine_I_C_Im)
{
	double ZB, SB, EB;
	complex tst, tst2, tst3, tst4;
current_A.Re()=pLine_I_A_Re;
current_B.Re()=pLine_I_B_Re;
current_C.Re()=pLine_I_C_Re;

current_A.Im()=pLine_I_A_Im;
current_B.Im()=pLine_I_B_Im;
current_C.Im()=pLine_I_C_Im;




	switch (Turbine_Model)	{
		case 5: //GENERIC_IND_LARGE
		case 2:	//Creates generic 1.5 MW wind turbine. //GENERIC_SYNC_LARGE
			blade_diam = 82.5;
			turbine_height = 90;
			q = 3;						//number of gearbox stages
			Rated_VA = 1635000;
			Max_P = 1500000;
			Max_Q = 650000;
			Rated_V = 600;
			pf = 0.95;
			CP_Data = 0;
			cut_in_ws = 4;			//lowest wind speed
			cut_out_ws = 25;		//highest wind speed
			Cp_max = 0.302;			//rotor specifications for power curve
			ws_maxcp = 7;
			Cp_rated = Cp_max-.05;
			ws_rated = 12.5;
			if (Turbine_Model == 5/*GENERIC_IND_LARGE*/) {
				Gen_type = 1;//1;INDUCTION;
				Rst = 0.12;
				Xst = 0.17;
				Rr = 0.12;
				Xr = 0.15;
				Rc = 999999;
				Xm = 9.0;
			}
			else if (Turbine_Model == 2) {
				Gen_type = 2;//SYNCHRONOUS;
				Rs = 0.05;
				Xs = 0.200;
				Rg = 0.000;
				Xg = 0.000;
			}
			break;
		case 4:
		case 1:	//Creates generic 100kW wind turbine, northwind 100
			blade_diam = 23.2;   //in m
			turbine_height = 30;   //in m
			q = 0;						//number of gearbox stages, no gear box
			Rated_VA = 156604;
			Max_P = 150000;
			Max_Q = 45000;
			Rated_V = 480;
			pf = 0.9;     ///lag and lead of 0.9
			CP_Data = 1;
			cut_in_ws = 3.5;			//lowest wind speed in m/s
			cut_out_ws = 25;		   //highest wind speed in m/s
			Cp_max = 0.302;			  //rotor specifications for power curve
			ws_maxcp = 7;
			Cp_rated = Cp_max-.05;
			ws_rated = 14.5;		//	in m/s
			if (Turbine_Model == 4) {     // need to check the machine parameters
				Gen_type = 1;
				Rst = 0.12;
				Xst = 0.17;
				Rr = 0.12;
				Xr = 0.15;
				Rc = 999999;
				Xm = 9.0;
			}
			else if (Turbine_Model == 1) {
				Gen_type = 1;
				Rs = 0.05;
				Xs = 0.200;
				Rg = 0.000;
				Xg = 0.000;
			}
			break;
		case 3:
		case 0:	//Creates generic 5 kW wind turbine, Fortis Montana 5 kW wind turbine
			blade_diam = 5;      // in m
			turbine_height = 16;   //in m
			q = 0;						//number of gearbox stages, no gear box
			Rated_VA = 6315;               // calculate from P & Q
			Max_P = 5800;
			Max_Q = 2500;
			Rated_V = 600;
			pf = 0.95;
			CP_Data = 2;
			cut_in_ws = 2.5;			//lowest wind speed
			cut_out_ws = 25;		//highest wind speed
			Cp_max = 0.302;			//rotor specifications for power curve
			ws_maxcp = 7;			//	|
			Cp_rated = Cp_max-.05;	//	|
			ws_rated = 17;		//	|
			if (Turbine_Model == 3) {
				Gen_type = 1;
				Rst = 0.12;
				Xst = 0.17;
				Rr = 0.12;
				Xr = 0.15;
				Rc = 999999;
				Xm = 9.0;
			}
			else if (Turbine_Model == 0) {
				Gen_type = 2;
				Rs = 0.05;
				Xs = 0.200;
				Rg = 0.000;
				Xg = 0.000;
			}
			break;
		case 7:	//Include manufacturer's data - cases can be added to call other wind turbines
			turbine_height = 78;
			blade_diam = 82;
			Rated_VA = 1808000;
			Rated_V = 600;
			Max_P = 1650000;
			Max_Q = 740000;
			pf = 0.91;		//Can range between 0.65-1.00 depending on controllers and Pout.
			CP_Data = 2;
			cut_in_ws = 3.5;
			cut_out_ws = 20;
			q = 2;
			Gen_type = 2;	//V82 actually uses a DFIG, but will use synch representation for now
			Rs = 0.025;				//Estimated values for synch representation.
			Xs = 0.200;
			Rg = 0.000;
			Xg = 0.000;
			break;
		case 8:
			turbine_height = 100;
			blade_diam = 100;
			Rated_VA = 2727000;
			Rated_V = 690;
			Max_P = 2500000;
			Max_Q = 1090000;
			pf = 0.95;		//ranges between -0.9 -> 0.9;
			q = 3;
			CP_Data = 0;
			cut_in_ws = 3.5;
			cut_out_ws = 25;
			Cp_max = 0.28;
			Cp_rated = 0.275;
			ws_maxcp = 8.2;
			ws_rated = 12.5;
			Gen_type = 2;
			Rs = 0.035;
			Xs = 0.200;
			Rg = 0.000;
			Xg = 0.000;
			break;
		case 9:
			turbine_height = 24;
			blade_diam = 7;
			Rated_VA = 10000;
			Rated_V = 360;
			Max_P = 15000;
			Max_Q = 4000;
			pf = 0.95;		//ranges between -0.9 -> 0.9;
			q = 0;
			CP_Data = 2;
			cut_in_ws = 2;
			cut_out_ws = 20;
			Cp_max = 0.28;
			Cp_rated = 0.275;
			ws_maxcp = 8.2;
			ws_rated = 12.5;
			Gen_type = 2;
			Rs = 0.05;
			Xs = 0.200;
			Rg = 0.000;
			Xg = 0.000;
			break;
		case 6:

			CP_Data = 5;

			Gen_type = 3;
			Rs = 0.2;
			Xs = 0.2;
			Rg = 0.1;
			Xg = 0;

			if (turbine_height <=0)
				return 0;
				//GL_THROW ("turbine height cannot have a negative or zero value.");
			/*  TROUBLESHOOT
			Turbine height must be specified as a value greater than or equal to zero.
			*/
			if (blade_diam <=0)
				return 0;
				//GL_THROW ("turbine height cannot have a negative or zero value.");
			/*  TROUBLESHOOT
			Blade diameter must be specified as a value greater than or equal to zero.
			*/
			if (cut_in_ws <=0)
				return 0;
				//GL_THROW ("turbine height cannot have a negative or zero value.");
			/*  TROUBLESHOOT
			Cut in wind speed must be specified as a value greater than or equal to zero.
			*/
			if (cut_out_ws <=0)
				return 0;
				//GL_THROW ("cut out wind speed cannot have a negative or zero value.");
			/*  TROUBLESHOOT
			Cut out wind speed must be specified as a value greater than or equal to zero.
			*/
			if (ws_rated <=0)
				return 0;
				//GL_THROW ("rated wind speed cannot have a negative or zero value.");
			/*  TROUBLESHOOT
			Rated wind speed must be specified as a value greater than or equal to zero.
			*/
			if (ws_maxcp <=0)
				return 0;
				//GL_THROW ("max cp cannot have a negative or zero value.");
			/*  TROUBLESHOOT
			Maximum coefficient of performance must be specified as a value greater than or equal to zero.
			*/
			break;
		default:
			return 0;
				//GL_THROW("Unknown turbine model was specified");
			/*  TROUBLESHOOT
			An unknown wind turbine model was selected.  Please select a Turbine_Model from the available list.
			*/
	}







	windturb_dginit_climate();

	return 1;

}

double my_wind_turbineImpl::windturb_dgsync(double pCircuit_V_A_Re, double pCircuit_V_A_Im, double pCircuit_V_B_Re, double pCircuit_V_B_Im, double pCircuit_V_C_Re, double pCircuit_V_C_Im)
{
 	int t2 = TS_NEVER;

		double Pwind, Pmech, detCp, F, G, gearbox_eff;
		double matCp[2][3];

		store_last_current = current_A.Mag() + current_B.Mag() + current_C.Mag();

		// convert press to Pascals and temp to Kelvins

		air_dens = (*pPress*100) * Molar / (Ridealgas * ( (*pTemp - 32)*5/9 + 273.15));

		//wind speed at height of hub - uses European Wind Atlas method
		WSadj = *pWS * log(turbine_height/roughness_l)/log(ref_height/roughness_l);

		double test = *pPress;


		Pwind = 0.5 * (air_dens) * PI * pow(blade_diam/2,2) * pow(WSadj,3);



		if (CP_Data == 0 || CP_Data == 1 || CP_Data == 2)
		{
			if (WSadj <= cut_in_ws)
			{
				Cp = 0;
			}

			else if (WSadj > cut_out_ws)
			{
				Cp = 0;
			}

			else if(WSadj > ws_rated)
			{
				Cp = Cp_rated * pow(ws_rated,3) / pow(WSadj,3);
			}
			else
			{
				if (WSadj == 0 || WSadj <= cut_in_ws || WSadj >= cut_out_ws)
				{
					Cp = 0;
				}
				else {
					matCp[0][0] = pow((ws_maxcp/cut_in_ws - 1),2);   //Coeff of Performance found
					matCp[0][1] = pow((ws_maxcp/cut_in_ws - 1),3);	 //by using method described in [1]
					matCp[0][2] = 1;
					matCp[1][0] = pow((ws_maxcp/ws_rated - 1),2);
					matCp[1][1] = pow((ws_maxcp/ws_rated - 1),3);
					matCp[1][2] = 1 - Cp_rated/Cp_max;
					detCp = matCp[0][0]*matCp[1][1] - matCp[0][1]*matCp[1][0];

					F = (matCp[0][2]*matCp[1][1] - matCp[0][1]*matCp[1][2])/detCp;
					G = (matCp[0][0]*matCp[1][2] - matCp[0][2]*matCp[1][0])/detCp;

					Cp = Cp_max*(1 - F*pow((ws_maxcp/WSadj - 1),2) - G*pow((ws_maxcp/WSadj - 1),3));
				}
			}
		}
		else if (CP_Data == 3)	//Coefficient of Perfomance generated from Manufacturer's table
		{
			switch (Turbine_Model)	{
				case 7:
					if (WSadj <= cut_in_ws || WSadj >= cut_out_ws)
					{
						Cp = 0;
					}
					else  //TO DO:  possibly replace polynomial with spline library function interpolation
					{
						//Uses a centered, 10th-degree polynomial Matlab interpolation of original Manuf. data
						double z = (WSadj - 10.5)/5.9161;

						//Original data [0 0 0 0 0.135 0.356 0.442 0.461 .458 .431 .397 .349 .293 .232 .186 .151 .125 .104 .087 .074 .064] from 4-20 m/s
						Cp = -0.08609*pow(z,10) + 0.078599*pow(z,9) + 0.50509*pow(z,8) - 0.45466*pow(z,7) - 0.94154*pow(z,6) + 0.77922*pow(z,5) + 0.59082*pow(z,4) - 0.23196*pow(z,3) - 0.25009*pow(z,2) - 0.24282*z + 0.37502;
					}
					break;
				default:
				return 0;
					//GL_THROW("Coefficient of Performance model not determined.");
			}

		}
		else if (CP_Data == 4)
		{
			matCp[0][0] = pow((ws_maxcp/cut_in_ws - 1),2);   //Coeff of Performance found
			matCp[0][1] = pow((ws_maxcp/cut_in_ws - 1),3);	 //by using method described in [1]
			matCp[0][2] = 1;
			matCp[1][0] = pow((ws_maxcp/ws_rated - 1),2);
			matCp[1][1] = pow((ws_maxcp/ws_rated - 1),3);
			matCp[1][2] = 1 - Cp_rated/Cp_max;
			detCp = matCp[0][0]*matCp[1][1] - matCp[0][1]*matCp[1][0];

			F = (matCp[0][2]*matCp[1][1] - matCp[0][1]*matCp[1][2])/detCp;
			G = (matCp[0][0]*matCp[1][2] - matCp[0][2]*matCp[1][0])/detCp;

			Cp = Cp_max*(1 - F*pow((ws_maxcp/WSadj - 1),2) - G*pow((ws_maxcp/WSadj - 1),3));
		}
		else
		{ return 0;
			//GL_THROW("CP_Data not defined.");
		}

		/// define user defined data , also catch for future cases

		Pmech = Pwind * Cp;

		if (Pmech != 0)
		{
			gearbox_eff = 1 - (q*.01*Rated_VA / Pmech);	 //Method described in [2].

			if (gearbox_eff < .1)
			{
				gearbox_eff = .1;	//Prevents efficiency from becoming negative at low power.
			}

			Pmech = Pwind * Cp * gearbox_eff;
		}

		Pconv = 1 * Pmech;  //TODO: Assuming 0% losses due to friction and miscellaneous losses

		if (Gen_status==2)
		{
			int k;
			voltage_A.Re()=pCircuit_V_A_Re;
			voltage_B.Re()=pCircuit_V_B_Re;
			voltage_C.Re()=pCircuit_V_C_Re;

			voltage_A.Im()=pCircuit_V_A_Im;
			voltage_B.Im()=pCircuit_V_B_Im;
			voltage_C.Im()=pCircuit_V_C_Im;

			double Pconva = (voltage_A.Mag() / (voltage_A.Mag() + voltage_B.Mag() + voltage_C.Mag()))*Pconv;
			double Pconvb = (voltage_B.Mag() / (voltage_A.Mag() + voltage_B.Mag() + voltage_C.Mag()))*Pconv;
			double Pconvc = (voltage_C.Mag() / (voltage_A.Mag() + voltage_B.Mag() + voltage_C.Mag()))*Pconv;

			if (Gen_type == 1)	//TO DO:  Induction gen. Ef not working correctly yet.
			{
				Pconva = Pconva/Rated_VA;					//induction generator solved in pu
				Pconvb = Pconvb/Rated_VA;
				Pconvc = Pconvc/Rated_VA;

				Vapu = voltage_A/(Rated_V/sqrt(3.0));
				Vbpu = voltage_B/(Rated_V/sqrt(3.0));
				Vcpu = voltage_C/(Rated_V/sqrt(3.0));

				Vrotor_A = Vapu;
				Vrotor_B = Vbpu;
				Vrotor_C = Vcpu;

				complex detTPMat = IndTPMat[1][1]*IndTPMat[0][0] - IndTPMat[1][0]*IndTPMat[0][1];

				if (Pconv > 0)
				{
					switch (Gen_mode)
					{
					case 1:
						for(k = 0; k < 6; k++) //TODO: convert to a convergence
						{
							Irotor_A = (~((complex(Pconva,0)/Vrotor_A)));
							Irotor_B = (~((complex(Pconvb,0)/Vrotor_B)));
							Irotor_C = (~((complex(Pconvc,0)/Vrotor_C)));

							Iapu = IndTPMat[1][0]*Vrotor_A + IndTPMat[1][1]*Irotor_A;
							Ibpu = IndTPMat[1][0]*Vrotor_B + IndTPMat[1][1]*Irotor_B;
							Icpu = IndTPMat[1][0]*Vrotor_C + IndTPMat[1][1]*Irotor_C;

							Vrotor_A = complex(1,0)/detTPMat * (IndTPMat[1][1]*Vapu - IndTPMat[0][1]*Iapu);
							Vrotor_B = complex(1,0)/detTPMat * (IndTPMat[1][1]*Vbpu - IndTPMat[0][1]*Ibpu);
							Vrotor_C = complex(1,0)/detTPMat * (IndTPMat[1][1]*Vcpu - IndTPMat[0][1]*Icpu);

							Vrotor_A = Vrotor_A * Max_Vrotor / Vrotor_A.Mag();
							Vrotor_B = Vrotor_B * Max_Vrotor / Vrotor_B.Mag();
							Vrotor_C = Vrotor_C * Max_Vrotor / Vrotor_C.Mag();
						}
						break;
					case 3:
						double last_Ipu = 0;
						double current_Ipu = 1;
						unsigned int temp_ind = 1;

						while ( fabs( (last_Ipu-current_Ipu)/current_Ipu) > 0.005 )
						{
							last_Ipu = current_Ipu;

							Irotor_A = -(~complex(-Pconva/Vrotor_A.Mag()*cos(Vrotor_A.Arg()),Pconva/Vrotor_A.Mag()*sin(Vrotor_A.Arg())));
							Irotor_B = -(~complex(-Pconvb/Vrotor_B.Mag()*cos(Vrotor_B.Arg()),Pconvb/Vrotor_B.Mag()*sin(Vrotor_B.Arg())));
							Irotor_C = -(~complex(-Pconvc/Vrotor_C.Mag()*cos(Vrotor_C.Arg()),Pconvc/Vrotor_C.Mag()*sin(Vrotor_C.Arg())));

							Iapu = IndTPMat[1][0]*Vrotor_A - IndTPMat[1][1]*Irotor_A;
							Ibpu = IndTPMat[1][0]*Vrotor_B - IndTPMat[1][1]*Irotor_B;
							Icpu = IndTPMat[1][0]*Vrotor_C - IndTPMat[1][1]*Irotor_C;

							Vrotor_A = complex(1,0)/detTPMat * (IndTPMat[1][1]*Vapu - IndTPMat[0][1]*Iapu);
							Vrotor_B = complex(1,0)/detTPMat * (IndTPMat[1][1]*Vbpu - IndTPMat[0][1]*Ibpu);
							Vrotor_C = complex(1,0)/detTPMat * (IndTPMat[1][1]*Vcpu - IndTPMat[0][1]*Icpu);

							current_Ipu = Iapu.Mag() + Ibpu.Mag() + Icpu.Mag();

							temp_ind += 1;
							if (temp_ind > 100)
							{


								//gl_warning("windturb_dg (id:%d,name:%s): internal iteration limit reached, breaking out of loop.  Injected current may not be solved sufficiently.",obj->id,obj->name);
								/* TROUBLESHOOT
								This may need some work.  The generator models are solved iteratively by using the system voltage
								as the boundary condition.  The current model iterates on solving the current injection, but then
								breaks out if not solved within 100 iterations.  May indicate some issues with the model (i.e.,
								voltage is incorrectly set on the connection node) or it may indicate poor programming.  Please report
								if you see this message.
								*/
								break;
							}
						}
						break;
					}

					// convert current back out of p.u.
					current_A = Iapu * Rated_VA/(Rated_V/sqrt(3.0));
					current_B = Ibpu * Rated_VA/(Rated_V/sqrt(3.0));
					current_C = Icpu * Rated_VA/(Rated_V/sqrt(3.0));
				}
				else // Generator is offline
				{
					current_A = 0;
					current_B = 0;
					current_C = 0;
				}
			}

			else if (Gen_type == 2)			//synch gen is NOT solved in pu
			{											//sg ef mode is not working yet
				double Mxef, Mnef, PoutA, PoutB, PoutC, QoutA, QoutB, QoutC;
				complex SoutA, SoutB, SoutC;
				complex lossesA, lossesB, lossesC;

				Mxef = Max_Ef * Rated_V/sqrt(3.0);
				Mnef = Min_Ef * Rated_V/sqrt(3.0);

				//TODO: convert to a convergence
				if (Gen_mode == 1)	//Ef is controllable to give a needed power output.
				{
					current_A = invAMx[0][0]*(voltage_A - EfA) + invAMx[0][1]*(voltage_B - EfB) + invAMx[0][2]*(voltage_C - EfC);
					current_B = invAMx[1][0]*(voltage_A - EfA) + invAMx[1][1]*(voltage_B - EfB) + invAMx[1][2]*(voltage_C - EfC);
					current_C = invAMx[2][0]*(voltage_A - EfA) + invAMx[2][1]*(voltage_B - EfB) + invAMx[2][2]*(voltage_C - EfC);

					SoutA = -voltage_A * (~(current_A));  //TO DO:  unbalanced
					SoutB = -voltage_B * (~(current_B));
					SoutC = -voltage_C * (~(current_C));

				}
				//Gives a constant output power of real power converted Pout,then Qout is found through a controllable power factor.
				else if (Gen_mode == 2)
				{
					//If air density increases, power extracted can be much greater than the default specifications - cap it.
					if (Pconva > 1.025*Max_P/3) {
						Pconva = 1.025*Max_P/3;
					}
					if (Pconvb > 1.025*Max_P/3) {
						Pconvb = 1.025*Max_P/3;
					}
					if (Pconvc > 1.025*Max_P/3) {
						Pconvc = 1.025*Max_P/3;
					}

					current_A = -(~(complex(Pconva,Pconva*tan(acos(pf)))/voltage_A));
					current_B = -(~(complex(Pconvb,Pconvb*tan(acos(pf)))/voltage_B));
					current_C = -(~(complex(Pconvc,Pconvc*tan(acos(pf)))/voltage_C));

					if (Pconv > 0)
					{
						double last_current = 0;
						double current_current = current_A.Mag() + current_B.Mag() + current_C.Mag();
						unsigned int temp_count = 1;

						while ( fabs( (last_current-current_current)/current_current) > 0.005 )
						{
							last_current = current_current;

							PoutA = Pconva - current_A.Mag()*current_A.Mag()*(AMx[0][0] - AMx[0][1]).Re();
							PoutB = Pconvb - current_B.Mag()*current_B.Mag()*(AMx[1][1] - AMx[0][1]).Re();
							PoutC = Pconvc - current_C.Mag()*current_C.Mag()*(AMx[2][2] - AMx[0][1]).Re();

							QoutA = pf/fabs(pf)*PoutA*sin(acos(pf));
							QoutB = pf/fabs(pf)*PoutB*sin(acos(pf));
							QoutC = pf/fabs(pf)*PoutC*sin(acos(pf));

							current_A = -(~(complex(PoutA,QoutA)/voltage_A));
							current_B = -(~(complex(PoutB,QoutB)/voltage_B));
							current_C = -(~(complex(PoutC,QoutC)/voltage_C));

							current_current = current_A.Mag() + current_B.Mag() + current_C.Mag();

							temp_count += 1;

							if ( temp_count > 100 )
							{


								//gl_warning("windturb_dg (id:%d,name:%s): internal iteration limit reached, breaking out of loop.  Injected current may not be solved sufficiently.",obj->id,obj->name);
								/* TROUBLESHOOT
								This may need some work.  The generator models are solved iteratively by using the system voltage
								as the boundary condition.  The current model iterates on solving the current injection, but then
								breaks out if not solved within 100 iterations.  May indicate some issues with the model (i.e.,
								voltage is incorrectly set on the connection node) or it may indicate poor programming.  Please report
								if you see this message.
								*/
								break;
							}
						}
						//gl_debug("windturb_dg iteration count = %d",temp_count);
					}
					else
					{
						current_A = 0;
						current_B = 0;
						current_C = 0;
					}

					EfA = voltage_A - (AMx[0][0] - AMx[0][1])*current_A - AMx[0][2]*(current_A + current_B + current_C);
					EfB = voltage_B - (AMx[1][1] - AMx[1][0])*current_A - AMx[1][2]*(current_A + current_B + current_C);
					EfC = voltage_C - (AMx[2][2] - AMx[2][0])*current_A - AMx[2][1]*(current_A + current_B + current_C);
				}
				else
				return 0;
					//GL_THROW("Unknown generator mode");
			}

			//sum up and finalize everything for output
			double PowerA, PowerB, PowerC, QA, QB, QC;

			PowerA = -voltage_A.Mag()*current_A.Mag()*cos(voltage_A.Arg() - current_A.Arg());
			PowerB = -voltage_B.Mag()*current_B.Mag()*cos(voltage_B.Arg() - current_B.Arg());
			PowerC = -voltage_C.Mag()*current_C.Mag()*cos(voltage_C.Arg() - current_C.Arg());

			QA = -voltage_A.Mag()*current_A.Mag()*sin(voltage_A.Arg() - current_A.Arg());
			QB = -voltage_B.Mag()*current_B.Mag()*sin(voltage_B.Arg() - current_B.Arg());
			QC = -voltage_C.Mag()*current_C.Mag()*sin(voltage_C.Arg() - current_C.Arg());

			power_A = complex(PowerA,QA);
			power_B = complex(PowerB,QB);
			power_C = complex(PowerC,QC);

			TotalRealPow = PowerA + PowerB + PowerC;
			TotalReacPow = QA + QB + QC;

			GenElecEff = TotalRealPow/Pconv * 100;

			Wind_Speed = WSadj;

			//complex testCurrent;
			//testCurrent = pLine_I_[0];




			//complex *testCurrentPointer;
			//testCurrentPointer = pLine_I;

				pLine_I_A_Re += current_A.Re();
			  			pLine_I_B_Re += current_B.Re();
			  			pLine_I_C_Re += current_C.Re();

			  		    pLine_I_A_Im += current_A.Im();
			  			pLine_I_B_Im += current_B.Im();
  			pLine_I_C_Im += current_C.Im();
		}
		// Generator is offline
		else
		{
			current_A = 0;
			current_B = 0;
			current_C = 0;

			power_A = complex(0,0);
			power_B = complex(0,0);
			power_C = complex(0,0);
		}
	//}


	//if ( fabs((store_current_current -store_last_current) / store_last_current) > 0.005 )
	//	t2 = t1;

	return TotalRealPow;

}

int my_wind_turbineImpl::windturb_dg_postsync(int t0, int t1)
{
	int t2 = TS_NEVER;
	// Handling for NR || FBS
	//if ( *NR_mode == true || ( *NR_mode == false && last_NR_mode == false ))
	//{
		//Remove our parent contributions (so XMLs look proper)

	//}

	//last_NR_mode = *NR_mode;

	return t2; /* return t2>t1 on success, t2=t1 for retry, t2<t1 on failure */

}



